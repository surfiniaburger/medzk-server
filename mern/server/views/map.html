<!DOCTYPE html>
<html>

<head>
    <title>3D Maps Codelab</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
       
      .pac-controls {
        display: inline-block;
        padding: 0px 11px;
      }
      .pac-controls label {
        font-family: Roboto;
        font-size: 13px;
        font-weight: 300;
      }
      .pac-card {
        background-color: #fff;
        border: 0;
        border-radius: 4px;
        box-shadow: 0 1px 4px -1px rgba(0, 0, 0, 0.3);
        margin: 10px;
        padding: 0 0.5em;
        font: 400 18px Roboto, Arial, sans-serif;
        overflow: hidden;
        font-family: Roboto;
        padding: 0;
        position: absolute;
        left: 10px;
        top: 50px;
        z-index: 1000;
      }
      #pac-container {
        padding-top: 12px;
        padding-bottom: 12px;
        margin-right: 12px;
        border-radius: 2px;
      }
      #pac-input {
        background-color: #fff;
        font-family: Roboto;
        font-size: 15px;
        font-weight: 300;
        margin-left: 12px;
        padding: 0 11px 0 13px;
        text-overflow: ellipsis;
        width: 400px;
      }
      #pac-input:focus {
        border-color: #4d90fe;
      }
      #info-window {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1000;
        }
      #title {
        color: #fff;
        background-color: #4d90fe;
        font-size: 14px;
        font-weight: 500;
        padding: 6px 12px;
      }
      #api-results {
  position: fixed; /* Keeps it in the same spot during scroll */
  top: 50%; /* Center vertically */
  left: 20px; /* Positioned slightly away from the left edge */
  transform: translateY(-50%); /* Aligns center properly */
  width: 250px; /* Smaller box */
  background-color: #f9f9f9; /* Light background for better readability */
  border: 1px solid #ddd; /* Subtle border */
  border-radius: 8px; /* Rounded corners for modern look */
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Soft shadow */
  padding: 16px; /* Inner spacing */
  font-family: 'Arial', sans-serif; /* Modern font */
  font-size: 14px; /* Readable text size */
  display: none; /* Hidden initially */
  z-index: 1000; /* Makes sure it stays above other elements */
}

#api-results h3 {
  font-size: 16px;
  color: #333; /* Darker text for better visibility */
  margin-bottom: 8px;
  text-align: center; /* Align title in the center */
}

#api-results ul {
  list-style-type: none; /* Removes bullet points */
  padding: 0; /* No extra padding */
  margin: 0; /* No extra margin */
}

#api-results ul li {
  margin-bottom: 6px;
  color: #555; /* Slightly muted text color */
  font-size: 14px;
}
.draggable {
    position: absolute;
    cursor: grab;
    padding: 10px;
    background: white;
    border: 1px solid #ccc;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    z-index: 1000;
}

.draggable:active {
    cursor: grabbing;
}
    </style>
</head>

<body>
    <div class="pac-card" id="pac-card">
        <div id="title">Navigate to a place</div>
        <div id="pac-container">
          <input class="pac-input" type="text" id="pac-input" name="pac-input" placeholder="Enter a location..." />
        </div>
      </div>

      <div id="api-results" class="draggable">
        <h3>Environmental Data:</h3>
        <ul id="api-data-list"> 
        </ul>
    </div>

    <div id="info-window" class="draggable"></div>

    
    <script async defer>
        (g => { var h, a, k, p = "The Google Maps JavaScript API", c = "google", l = "importLibrary", q = "__ib__", m = document, b = window; b = b[c] || (b[c] = {}); var d = b.maps || (b.maps = {}), r = new Set, e = new URLSearchParams, u = () => h || (h = new Promise(async (f, n) => { await (a = m.createElement("script")); e.set("libraries", [...r] + ""); for (k in g) e.set(k.replace(/[A-Z]/g, t => "_" + t[0].toLowerCase()), g[k]); e.set("callback", c + ".maps." + q); a.src = `https://maps.${c}apis.com/maps/api/js?` + e; d[q] = f; a.onerror = () => h = n(Error(p + " could not load.")); a.nonce = m.querySelector("script[nonce]")?.nonce || ""; m.head.append(a) })); d[l] ? console.warn(p + " only loads once. Ignoring:", g) : d[l] = (f, ...n) => r.add(f) && u().then(() => d[l](f, ...n)) })({
            key: "<%= apiKey %>",
            v: "alpha",
        });
    </script>
    <script>
      let map3DElement = null;
      let placesService = null;


      class InteractiveMarker {
    constructor(map3DElement, place) {
        this.map3DElement = map3DElement;
        this.place = place;
        this.marker = null;
    }

    async create() {
        // Import Marker3DInteractiveElement
        const { Marker3DInteractiveElement } = await google.maps.importLibrary("maps3d");
        
        // Create an instance of Marker3DInteractiveElement
        this.marker = new Marker3DInteractiveElement({
            position: {
                lat: this.place.geometry.location.lat(),
                lng: this.place.geometry.location.lng(),
                altitude: 0, // Assuming altitude is optional
            },
            label: this.place.name,
            sizePreserved: true, // Preserve marker size regardless of zoom
        });

        // Add click event listener to the marker
        this.marker.addEventListener('gmp-click', () => this.showInfoWindow());
        
        // Append the marker to the map's 3D element
        this.map3DElement.append(this.marker);
    }

    async showInfoWindow() {
        const infoWindow = document.getElementById("info-window");
        
        // Simulated fetch for additional data
        const data = await this.fetchData();
        
        // Populate and display the info window
        infoWindow.innerHTML = `
            <strong>${this.place.name}</strong><br>
            Address: ${this.place.vicinity || "Not available"}<br>
            Additional Info: ${data || "No data available"}
        `;
        infoWindow.style.display = "block";
    }

    async fetchData() {
        // Simulated data fetching with a delay
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve(`Simulated info for ${this.place.name}`);
            }, 1000);
        });
    }
}

    
      async function init() {
        const { Map3DElement } = await google.maps.importLibrary("maps3d");
        map3DElement = new Map3DElement({
          center: { lat: 0, lng: 0, altitude: 16000000 },
         // Adjust as needed
        });

        //await initializeMapAndElements();
        document.body.append(map3DElement);
        initAutocomplete();
        initPlacesService();
      }
    
      async function initAutocomplete() {
        const { Autocomplete } = await google.maps.importLibrary("places");
        const autocomplete = new Autocomplete(
          document.getElementById("pac-input"),
          {
            fields: ["geometry", "name", "place_id"],
          }
        );
    
        autocomplete.addListener("place_changed", () => {
          const place = autocomplete.getPlace();
          if (!place.geometry || !place.geometry.viewport) {
            window.alert("No viewport for input: " + place.name);
            return;
          }
          zoomToViewport(place.geometry);
        });
      }
    
      async function zoomToViewport(geometry) {
        const { AltitudeMode, Polyline3DElement } = await google.maps.importLibrary("maps3d");
        let viewport = geometry.viewport;
        let locationPoints = [
          { lat: viewport.getNorthEast().lat(), lng: viewport.getNorthEast().lng() },
          { lat: viewport.getSouthWest().lat(), lng: viewport.getNorthEast().lng() },
          { lat: viewport.getSouthWest().lat(), lng: viewport.getSouthWest().lng() },
          { lat: viewport.getNorthEast().lat(), lng: viewport.getSouthWest().lng() },
          { lat: viewport.getNorthEast().lat(), lng: viewport.getNorthEast().lng() }
        ];
    
        let locationPolyline = new Polyline3DElement({
          altitudeMode: AltitudeMode.CLAMP_TO_GROUND,
          strokeColor: "blue",
          strokeWidth: 10,
          coordinates: locationPoints,
        });
        map3DElement.append(locationPolyline);
    
        let elevation = await getElevationForPoint(geometry.location);
        if (map3DElement) {
          map3DElement.center = { lat: geometry.location.lat(), lng: geometry.location.lng(), altitude: elevation + 50 };
          map3DElement.heading = 0;
          map3DElement.range = 1000;
          map3DElement.tilt = 65;
        }
    
        initNearbySearch(geometry.location);
        await fetchEnvironmentalData(geometry.location);
      }
    
      async function initPlacesService() {
        const { PlacesService } = await google.maps.importLibrary("places");
        placesService = new PlacesService(map3DElement);
      }
    
      async function initNearbySearch(location) {
        if (!placesService) {
          console.error("PlacesService not initialized.");
          return;
        }
    
        const request = {
          location: location,
          radius: 500, // Search within 1km
          type: [
    "chiropractor",
    "dental_clinic",
    "dentist",
    "doctor",
    "drugstore",
    "hospital",
    "massage",
    "medical_lab",
    "pharmacy",
    "physiotherapist",
    "sauna",
    "skin_care_clinic",
    "spa",
    "tanning_studio",
    "wellness_center",
    "yoga_studio"
], 
        };
    
        placesService.nearbySearch(request, (results, status) => {
          if (status === google.maps.places.PlacesServiceStatus.OK) {
            results.forEach((place) => {
              const marker = new InteractiveMarker(map3DElement, place);
              marker.create();
            });
          } else {
            console.error("Nearby search failed: ", status);
          }
        });
      }


 
    
      function addMarker(place) {
        const { Marker3DElement } = google.maps.maps3d;
        const marker = new Marker3DElement({
          position: {
            lat: place.geometry.location.lat(),
            lng: place.geometry.location.lng(),
            altitude: 0, // Adjust if necessary
          },
          label: place.name,
          sizePreserved: true,
        });
        map3DElement.append(marker);
      }
    
      async function getElevationForPoint(location) {
        const { ElevationService } = await google.maps.importLibrary("elevation");
        const elevatorService = new google.maps.ElevationService();
        const elevationResponse = await elevatorService.getElevationForLocations({
          locations: [location],
        });
    
        if (!(elevationResponse.results && elevationResponse.results.length)) {
          window.alert("Insufficient elevation data.");
          return 0;
        }
        return elevationResponse.results[0].elevation || 10;
      }

      async function fetchEnvironmentalData(location) {
        const openweatherKey = "open-weather-api-key";
        const airQualityUrl = `https://api.openweathermap.org/data/2.5/air_pollution?lat=${location.lat()}&lon=${location.lng()}&appid=${openweatherKey}`;
        const weatherUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${location.lat()}&lon=${location.lng()}&appid=${openweatherKey}`;

    try {
        const [airQualityResponse, weatherResponse] = await Promise.all([
            fetch(airQualityUrl),
            fetch(weatherUrl),
        ]);

        const airQualityData = await airQualityResponse.json();
        const weatherData = await weatherResponse.json();

        displayEnvironmentalData({ airQuality: airQualityData, weather: weatherData });
    } catch (error) {
        console.error("Failed to fetch environmental data:", error);
    }
}

function displayEnvironmentalData(data) {
    const resultsBox = document.getElementById("api-results");
    const dataList = document.getElementById("api-data-list");

    // Clear previous data
    dataList.innerHTML = "";

    // Populate new data
    dataList.innerHTML += `
        <li>Air Quality Index: ${data.airQuality.list[0].main.aqi}</li>
        <li>Weather: ${data.weather.weather[0].description}</li>
        <li>Temperature: ${(data.weather.main.temp - 273.15).toFixed(2)}°C</li>
    `;

    // Show results box
    resultsBox.style.display = "block";
}

document.addEventListener("DOMContentLoaded", () => {
    const draggables = document.querySelectorAll(".draggable");

    draggables.forEach((element) => {
        element.addEventListener("mousedown", (e) => {
            let shiftX = e.clientX - element.getBoundingClientRect().left;
            let shiftY = e.clientY - element.getBoundingClientRect().top;

            const moveAt = (pageX, pageY) => {
                element.style.left = pageX - shiftX + "px";
                element.style.top = pageY - shiftY + "px";
            };

            const onMouseMove = (event) => {
                moveAt(event.pageX, event.pageY);
            };

            document.addEventListener("mousemove", onMouseMove);

            element.addEventListener("mouseup", () => {
                document.removeEventListener("mousemove", onMouseMove);
                element.onmouseup = null;
            });

            // Prevent default drag-and-drop behavior
            element.ondragstart = () => false;
        });
    });
});



class Marker3DInteractiveElement {
  constructor({ position, label, iconUrl, interactive = true }) {
    this.position = position;
    this.label = label;
    this.iconUrl = iconUrl;
    this.interactive = interactive;
    this.marker = null;
  }

  async create(map3DElement) {
    const { Marker3DElement } = await google.maps.importLibrary("maps3d");
    this.marker = new Marker3DElement({
      position: this.position,
      label: this.label,
      icon: this.iconUrl,
      sizePreserved: true,
    });
    map3DElement.append(this.marker);

    if (this.interactive) {
      this.marker.addEventListener("click", () => {
        new PlaceClick().handleClick(this.position);
      });
    }
  }
}

class PlaceClick {
  handleClick(position) {
    alert(`Clicked on marker at: ${position.lat}, ${position.lng}`);
    // Fetch and display more detailed information or navigate on the map
  }
}

class Model3DElement {
  constructor({ position, modelUrl }) {
    this.position = position;
    this.modelUrl = modelUrl;
    this.model = null;
  }

  async create(map3DElement) {
    const { Model3DElement } = await google.maps.importLibrary("maps3d");
    this.model = new Model3DElement({
      position: this.position,
      model: this.modelUrl,
      scale: 1,
    });
    map3DElement.append(this.model);
  }
}

async function initializeMapAndElements() {
  if (!map3DElement) {
    console.error("map3DElement is not initialized.");
    return;
  }

  const mapCenter = { lat: 40.748817, lng: -73.985428 }; // Example location

  try {
    // Add an interactive marker
    const interactiveMarker = new google.maps.maps3d.Marker3DInteractiveElement({
      position: mapCenter,
      label: "Empire State Building",
    });

    interactiveMarker.addEventListener("gmp-click", () => {
      alert("Clicked on: Empire State Building");
    });

    map3DElement.append(interactiveMarker);

    // Add a 3D model
    const model = new google.maps.maps3d.Model3DElement({
      position: mapCenter,
      src: "https://www.3dpea.com/printable-detail/Uploads files 2922141 Groot Final-47Rac9",
      scale: 1.0, // Adjust as needed
    });

    map3DElement.append(model);
  } catch (error) {
    console.error("Failed to initialize map and elements:", error);
  }
}   
      init();
    </script>
    
</body>
</html>