<!DOCTYPE html>
<html>
<!-- Previous HTML content remains the same until the AirflowVisualizer class -->

<script>
// ... Previous code remains the same ...

class AirflowVisualizer {
    constructor(map3DElement) {
        this.map3DElement = map3DElement;
        this.particles = [];
        this.isAnimating = false;
        this.particleCount = 200;
        this.windSpeed = 1;
        this.windDirection = 0;
        this.pollutionLevel = 0;
        this.Overlay3DElement = null; // Initialize to null
        this.isInitialized = false; // Add initialization flag
        
        // Initialize the visualization system
        this.init();
    }

    async init() {
        try {
            // Import the Overlay3DElement class
            const { Overlay3DElement } = await google.maps.importLibrary("maps3d");
            this.Overlay3DElement = Overlay3DElement; // Store the class
            this.isInitialized = true; // Set initialization flag
            
            // Create particle container
            this.particleContainer = document.createElement('div');
            this.particleContainer.style.position = 'absolute';
            this.particleContainer.style.width = '100%';
            this.particleContainer.style.height = '100%';
            this.particleContainer.style.pointerEvents = 'none';
            this.map3DElement.appendChild(this.particleContainer);
            
            console.log("AirflowVisualizer initialized successfully");
        } catch (error) {
            console.error("Failed to initialize AirflowVisualizer:", error);
            throw error;
        }
    }

    async start(location, environmentalData) {
        // Wait for initialization if necessary
        if (!this.isInitialized) {
            console.log("Waiting for initialization...");
            await this.init();
        }

        // Verify Overlay3DElement is available
        if (!this.Overlay3DElement) {
            console.error("Overlay3DElement is not available. Cannot visualize airflow.");
            return;
        }

        if (this.isAnimating) return;
        this.isAnimating = true;
        this.location = location;
        
        // Set parameters based on environmental data
        this.updateParameters(environmentalData);

        const animate = () => {
            if (!this.isAnimating) return;

            // Update existing particles
            this.particles = this.particles.filter(particle => {
                const alive = this.updateParticle(particle);
                if (!alive) {
                    particle.remove();
                    return false;
                }
                return true;
            });

            // Add new particles
            while (this.particles.length < this.particleCount) {
                this.particles.push(this.createParticle(location));
            }

            requestAnimationFrame(animate);
        };

        animate();
    }

    createParticle(location) {
        if (!this.Overlay3DElement) {
            console.error("Overlay3DElement is not available.");
            return null;
        }

        // Create a custom 3D overlay for the particle
        const particle = new this.Overlay3DElement({
            position: {
                lat: location.lat + (Math.random() - 0.5) * 0.01,
                lng: location.lng + (Math.random() - 0.5) * 0.01,
                altitude: Math.random() * 300
            },
            scale: {
                x: 5,
                y: 5,
                z: 5
            }
        });

        // Create visual element
        const element = document.createElement('div');
        element.className = 'air-particle';
        element.style.cssText = `
            width: 8px;
            height: 8px;
            background: rgba(200, 200, 200, 0.6);
            border-radius: 50%;
            pointer-events: none;
        `;
        
        particle.element = element;
        particle.append(element);
        
        particle.velocity = {
            lat: (Math.random() - 0.5) * 0.0001,
            lng: (Math.random() - 0.5) * 0.0001,
            altitude: (Math.random() - 0.5) * 2
        };
        particle.lifetime = 0;
        particle.maxLife = Math.random() * 200 + 100;

        this.map3DElement.append(particle);
        return particle;
    }

    // ... Rest of the class methods remain the same ...
}

// ... Rest of the code remains the same ...
</script>
</html>



<!DOCTYPE html>
<html>
<!-- Previous HTML content remains the same until the AirflowVisualizer class -->

<script>
// ... Previous code remains the same ...

class AirflowVisualizer {
    constructor(map3DElement) {
        this.map3DElement = map3DElement;
        this.particles = [];
        this.isAnimating = false;
        this.particleCount = 200;
        this.windSpeed = 1;
        this.windDirection = 0;
        this.pollutionLevel = 0;
        this.Overlay3DElement = null;
        this.isInitialized = false;
        
        // Initialize immediately
        this.initPromise = this.init();
    }

    async init() {
        try {
            // Wait for the map to be fully loaded
            await new Promise(resolve => {
                if (this.map3DElement.isConnected) {
                    resolve();
                } else {
                    this.map3DElement.addEventListener('load', resolve, { once: true });
                }
            });

            // Import required libraries
            const { Overlay3DElement } = await google.maps.importLibrary("maps3d");
            
            // Store the Overlay3DElement class
            this.Overlay3DElement = Overlay3DElement;
            
            // Create particle container
            this.particleContainer = document.createElement('div');
            this.particleContainer.style.position = 'absolute';
            this.particleContainer.style.width = '100%';
            this.particleContainer.style.height = '100%';
            this.particleContainer.style.pointerEvents = 'none';
            this.map3DElement.appendChild(this.particleContainer);
            
            this.isInitialized = true;
            console.log("AirflowVisualizer initialized successfully");
        } catch (error) {
            console.error("Failed to initialize AirflowVisualizer:", error);
            throw error;
        }
    }

    async ensureInitialized() {
        if (!this.isInitialized) {
            await this.initPromise;
        }
        if (!this.Overlay3DElement) {
            throw new Error("Overlay3DElement is not available after initialization");
        }
    }

    async start(location, environmentalData) {
        try {
            // Ensure initialization is complete
            await this.ensureInitialized();
            
            if (this.isAnimating) return;
            this.isAnimating = true;
            this.location = location;
            
            // Set parameters based on environmental data
            this.updateParameters(environmentalData);

            const animate = () => {
                if (!this.isAnimating) return;

                // Update existing particles
                this.particles = this.particles.filter(particle => {
                    const alive = this.updateParticle(particle);
                    if (!alive) {
                        particle.remove();
                        return false;
                    }
                    return true;
                });

                // Add new particles
                while (this.particles.length < this.particleCount) {
                    const newParticle = this.createParticle(location);
                    if (newParticle) {
                        this.particles.push(newParticle);
                    }
                }

                requestAnimationFrame(animate);
            };

            animate();
        } catch (error) {
            console.error("Failed to start visualization:", error);
            this.isAnimating = false;
        }
    }

    createParticle(location) {
        try {
            if (!this.Overlay3DElement) {
                throw new Error("Overlay3DElement is not available");
            }

            // Create a custom 3D overlay for the particle
            const particle = new this.Overlay3DElement({
                position: {
                    lat: location.lat + (Math.random() - 0.5) * 0.01,
                    lng: location.lng + (Math.random() - 0.5) * 0.01,
                    altitude: Math.random() * 300
                }
            });

            // Create visual element
            const element = document.createElement('div');
            element.className = 'air-particle';
            element.style.cssText = `
                width: 8px;
                height: 8px;
                background: rgba(200, 200, 200, 0.6);
                border-radius: 50%;
                pointer-events: none;
            `;
            
            particle.element = element;
            particle.append(element);
            
            particle.velocity = {
                lat: (Math.random() - 0.5) * 0.0001,
                lng: (Math.random() - 0.5) * 0.0001,
                altitude: (Math.random() - 0.5) * 2
            };
            particle.lifetime = 0;
            particle.maxLife = Math.random() * 200 + 100;

            this.map3DElement.append(particle);
            return particle;
        } catch (error) {
            console.error("Failed to create particle:", error);
            return null;
        }
    }

    updateParticle(particle) {
        try {
            if (!particle) return false;

            // Get current position
            const position = particle.position;
            
            // Apply wind effect
            position.lat += Math.cos(this.windDirection) * this.windSpeed * 0.00001;
            position.lng += Math.sin(this.windDirection) * this.windSpeed * 0.00001;
            
            // Add turbulence
            position.lat += particle.velocity.lat;
            position.lng += particle.velocity.lng;
            position.altitude += particle.velocity.altitude;

            // Keep particles within bounds
            if (position.altitude < 0) position.altitude = 0;
            if (position.altitude > 500) position.altitude = 500;

            // Update particle color based on pollution level
            const r = Math.min(255, this.pollutionLevel * 2);
            const opacity = Math.min(0.8, 0.2 + (this.pollutionLevel / 100) * 0.6);
            particle.element.style.background = `rgba(${r}, ${200 - r}, ${200 - r}, ${opacity})`;

            // Update particle position
            particle.position = position;

            // Update lifetime
            particle.lifetime++;
            return particle.lifetime < particle.maxLife;
        } catch (error) {
            console.error("Failed to update particle:", error);
            return false;
        }
    }

    updateParameters(environmentalData) {
        this.pollutionLevel = environmentalData.aqi || 0;
        this.windSpeed = environmentalData.windSpeed || 1;
        this.windDirection = ((environmentalData.windDirection || 0) * Math.PI / 180);
        this.particleCount = Math.min(300, 100 + this.pollutionLevel);
    }

    stop() {
        this.isAnimating = false;
        this.particles.forEach(particle => {
            if (particle && particle.remove) {
                particle.remove();
            }
        });
        this.particles = [];
    }
}

// ... Rest of the code remains the same ...
</script>
</html>