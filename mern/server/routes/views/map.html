<!DOCTYPE html>
<html>

<head>
    <title>Zero Kare</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

          /* New styles for advanced features */
          .feature-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .feature-button {
            background: #4d90fe;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .feature-button:hover {
            background: #357ABD;
            transform: translateY(-2px);
        }

        .feature-button i {
            font-size: 18px;
        }


        .emergency-alert {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff4757;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            display: none;
            animation: slideUp 0.3s ease-out;
            z-index: 1002;
        }

        @keyframes slideUp {
            from {
                transform: translate(-50%, 100%);
            }
            to {
                transform: translate(-50%, 0);
            }
        }

        

        .community-panel {
            position: fixed;
            right: -400px;
            top: 50%;
            transform: translateY(-50%);
            width: 350px;
            background: white;
            border-radius: 15px 0 0 15px;
            padding: 20px;
            transition: right 0.3s ease;
            box-shadow: -5px 0 15px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .community-panel.active {
            right: 0;
        }
      .pac-controls {
        display: inline-block;
        padding: 0px 11px;
      }
      .pac-controls label {
        font-family: Roboto;
        font-size: 13px;
        font-weight: 300;
      }
      .pac-card {
        background-color: #fff;
        border: 0;
        border-radius: 4px;
        box-shadow: 0 1px 4px -1px rgba(0, 0, 0, 0.3);
        margin: 10px;
        padding: 0 0.5em;
        font: 400 18px Roboto, Arial, sans-serif;
        overflow: hidden;
        font-family: Roboto;
        padding: 0;
        position: absolute;
        left: 10px;
        top: 50px;
        z-index: 1000;
      }
    /* Input Container */
#pac-container {
    display: flex;
    flex-direction: column;
}

.pac-input {
    width: 100%;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 1rem;
    box-sizing: border-box;
}

.pac-input:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
}

/* Media Query for Larger Screens */
@media (min-width: 768px) {
    #pac-card {
        flex-direction: row;
        align-items: center;
        gap: 15px;
        max-width: 600px;
    }

    #title {
        flex: 1;
        text-align: left;
        margin-bottom: 0;
    }

    #pac-container {
        flex: 2;
    }
}
      #title {
        color: #fff;
        background-color: #4d90fe;
        font-size: 14px;
        font-weight: 500;
        padding: 6px 12px;
      }
      #api-results {
  position: fixed; /* Keeps it in the same spot during scroll */
  top: 50%; /* Center vertically */
  left: 20px; /* Positioned slightly away from the left edge */
  transform: translateY(-50%); /* Aligns center properly */
  width: 250px; /* Smaller box */
  background-color: #f9f9f9; /* Light background for better readability */
  border: 1px solid #ddd; /* Subtle border */
  border-radius: 8px; /* Rounded corners for modern look */
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Soft shadow */
  padding: 16px; /* Inner spacing */
  font-family: 'Arial', sans-serif; /* Modern font */
  font-size: 14px; /* Readable text size */
  display: none; /* Hidden initially */
  z-index: 1000; /* Makes sure it stays above other elements */
}

#api-results h3 {
  font-size: 16px;
  color: #333; /* Darker text for better visibility */
  margin-bottom: 8px;
  text-align: center; /* Align title in the center */
}

#api-results ul {
  list-style-type: none; /* Removes bullet points */
  padding: 0; /* No extra padding */
  margin: 0; /* No extra margin */
}

#api-results ul li {
  margin-bottom: 6px;
  color: #555; /* Slightly muted text color */
  font-size: 14px;
}


.draggable {
    position: absolute;
    cursor: grab;
    padding: 10px;
    background: white;
    border: 1px solid #ccc;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    z-index: 1000;
}

.info-card {
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    padding: 15px;
    max-width: 300px;  /* Reduced from 400px */
    position: relative;
    animation: slideIn 0.3s ease-out;
    overflow: hidden;
    font-size: 0.9rem;  /* Reduced base font size */
}

@keyframes slideIn {
    from {
        transform: translateY(-20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.close-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    background: #ff4757;
    color: white;
    border: none;
    border-radius: 50%;
    width: 24px;    /* Reduced from 30px */
    height: 24px;   /* Reduced from 30px */
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;  /* Reduced from 18px */
}

.close-btn:hover {
    transform: rotate(90deg);
    background: #ff6b81;
}

.place-title {
    font-size: 1.2em;  /* Reduced from 1.5em */
    color: #2f3542;
    margin-bottom: 10px;
    padding-right: 30px;
}

.info-section {
    margin: 5px 0;     /* Reduced from 8px */
    padding: 5px 8px;  /* Reduced from 8px */
    border-left: 2px solid #70a1ff;  /* Reduced from 3px */
    background: #f1f2f6;
    border-radius: 0 6px 6px 0;
    line-height: 1.3;  /* Added for better text spacing */
}

.place-image {
    width: 100%;
    height: 150px;    /* Fixed height */
    object-fit: cover; /* Ensures image covers area without distortion */
    border-radius: 8px;
    margin: 10px 0;
    transition: transform 0.3s;
}

.rating {
    background: #ffd32a;
    color: #2f3542;
    padding: 3px 8px;
    border-radius: 15px;
    display: inline-block;
    font-weight: bold;
    font-size: 0.9em;
}

.author-link {
    color: #70a1ff;
    text-decoration: none;
    transition: color 0.2s;
}

.author-link:hover {
    color: #1e90ff;
}

/* Added to truncate long text */
.truncate {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.draggable:active {
    cursor: grabbing;
}

.dashboard {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            font-family: Arial, sans-serif;
            margin-top: -20px;
          
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
            width: 100%; /* Ensure cards take full width of the dashboard */
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .gauge {
            width: 200px;
            height: 200px;
            margin: 0 auto;
            position: relative;
        }

        .gauge-bg {
            fill: none;
            stroke: #eee;
            stroke-width: 20;
        }

        .gauge-progress {
            fill: none;
            stroke-width: 20;
            stroke-linecap: round;
            transform: rotate(-90deg);
            transform-origin: 100px 100px;
            transition: stroke-dashoffset 1s ease;
        }

        @media (max-width: 768px) {
    .dashboard {
        grid-template-columns: 1fr; /* Stack cards vertically on smaller screens */
        padding: 10px; /* Reduce padding for smaller screens */
    }

    .card {
        
        margin-bottom: 20px; /* Add space between stacked cards */
    }

    .gauge {
        width: 150px; /* Adjust gauge size for mobile */
        height: 150px;
    }

    .gauge-value {
        font-size: 20px; /* Smaller font size for mobile */
    }

    #tempHumidityChart {
        width: 100% !important; /* Ensure canvas takes full width */
        height: auto !important; /* Maintain aspect ratio */
    }
}


        .place-cards-container {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  padding: 20px;
  justify-content: center;
}

.place-card {
  background: linear-gradient(145deg, #ffffff, #e6e6e6);
  box-shadow: 6px 6px 12px #d9d9d9, -6px -6px 12px #ffffff;
  border-radius: 12px;
  width: 300px;
  overflow: hidden;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.place-card:hover {
  transform: scale(1.05);
  box-shadow: 8px 8px 16px #cccccc, -8px -8px 16px #ffffff;
}

.place-card img {
  width: 100%;
  height: 200px;
  object-fit: cover;
  border-bottom: 2px solid #ccc;
}

.place-card-content {
  padding: 15px;
}

.place-card h2 {
  font-size: 1.2rem;
  color: #333;
  margin-bottom: 10px;
}

.place-card p {
  font-size: 0.9rem;
  color: #555;
  margin-bottom: 8px;
}

.place-card a {
  text-decoration: none;
  color: #007bff;
}

.place-card .rating {
  font-weight: bold;
  color: #ffaa00;
}


        .gauge-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
        }

        .pollutant-list {
            list-style: none;
            padding: 0;
        }

        .pollutant-item {
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            background: #f5f5f5;
        }

        .progress-bar {
            height: 10px;
            background: #eee;
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            transition: width 1s ease;
        }

        /* Add these styles to your existing CSS */

.fab-container {
    position: fixed;
    bottom: 30px;
    right: 30px;
    z-index: 1000;
}

.fab-button {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: #4d90fe;
    border: none;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    animation: bounce 1s infinite;
}

@keyframes bounce {
    0%, 100% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(-10px);
    }
}

.fab-button:hover {
    background: #357ABD;
    transform: scale(1.1);
    animation: none;
}

.fab-icon {
    font-size: 24px;
    color: white;
}

.dashboard-panel {
    position: fixed;
    right: 30px;
    bottom: 100px;
    background: white;
    border-radius: 15px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
    width: 90%;
    max-width: 1200px;
    max-height: 80vh;
    overflow-y: auto;
    padding: 20px; 
    display: none;
    animation: slideIn 0.3s ease-out;
    z-index: 999;
}

@keyframes slideIn {
    from {
        transform: translateY(100px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.panel-close-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    background: #ff4757;
    color: white;
    border: none;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    transition: all 0.2s;
    z-index: 1001;
}

.panel-close-btn:hover {
    transform: rotate(90deg);
    background: #ff6b81;
}


/* Add overlay style */
.overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    z-index: 998;
}

/* General Styles */
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

/* Search Icon */
.search-icon {
  font-size: 24px;
  color: #4d90fe;
  cursor: pointer;
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 1000;
  background: #fff;
  border-radius: 50%;
  padding: 10px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  animation: shake 1s infinite alternate;
}

@keyframes shake {
  0%, 100% {
    transform: translateX(0);
  }
  25% {
    transform: translateX(-5px);
  }
  75% {
    transform: translateX(5px);
  }
}

/* Popup Styles */
.popup {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 999;
  justify-content: center;
  align-items: center;
}

/* Close Button */
.popup-close-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    background: #ff4757;
    color: white;
    border: none;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    transition: all 0.2s;
    z-index: 1001;
}

.popup-close-btn:hover {
    transform: rotate(90deg);
    background: #ff6b81;
}


/* Responsive Card (reuse from your styles) */
#pac-card {
  display: flex;
  flex-direction: column;
  gap: 10px;
  background-color: #4d90fe;
  border-radius: 8px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  padding: 15px;
  box-sizing: border-box;
  color: white;
}

.home-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  background-color: #ffffff;
  border-radius: 50%;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  color: #4d90fe;
  font-size: 20px;
  margin: 0 auto;
}

.modal {
  display: none; /* Hidden by default */
  position: fixed;
  z-index: 1;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
}

.modal-content {
  background-color: #fefefe;
  margin: 15% auto;
  padding: 20px;
  border: 1px solid #888;
  width: 80%;
  border-radius: 10px;
  box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.2);
}



#alert-message {
    font-size: 18px; /* Larger font size for better visibility */
    color: #333; /* Dark gray color for text */
    margin-bottom: 20px; /* Space below message */
    text-align: center; /* Center align text */
    font-weight: bold; /* Make text bold */
}

/* Optional: Add additional styles for different types of messages */
.alert-success {
    color: green; /* Green color for success messages */
}

.alert-error {
    color: red; /* Red color for error messages */
}

#info-window { display: none; }

#canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .celebrate-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1001;
            transition: transform 0.3s ease;
        }

        .celebrate-btn:hover {
            background: #45a049;
            transform: scale(1.05);
        }

        .stop-btn {
            background: #f44336;
            display: none;
        }

        .stop-btn:hover {
            background: #d32f2f;
        }

        .confetti-active {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .duration-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 16px;
            display: none;
            z-index: 1001;
        }

        .location-icon {
    background: #fff;  /* White background */
    border: none;
    padding: 10px;        /* Adjust padding as needed */
    border-radius: 4px;   /* Slightly rounded corners */
    box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Subtle shadow */
    cursor: pointer;
    margin: 10px;       /* Add margin for spacing */
    display: flex;      /* Center the icon */
    align-items: center;
    z-index: 1000;       /* Ensure it's above other map elements */
}

.location-icon i {  /* Style for the Font Awesome icon */
    font-size: 18px;  /* Adjust icon size */
    color: #4d90fe;    /* Your preferred icon color */
}

.location-icon:hover {
    background: #f0f0f0; /* Slightly darker background on hover */
}
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>

<body>
    <div class="search-container">
        <!-- Search Icon -->
        <i class="fas fa-search search-icon" id="searchIcon" title="Search"></i>
      
        <!-- Popup -->
        <div class="popup" id="popup">
            <div class="pac-card " id="pac-card">
                <span class="popup-close-btn" id="popupCloseBtn">&times;</span>
              <div id="title">Navigate to a place</div>
              <div id="pac-container">
                <input
                  class="pac-input"
                  type="text"
                  id="pac-input"
                  name="pac-input"
                  placeholder="Enter a location..."
                />
              </div>
              
              <a href="https://www.zerokare.info/" class="home-icon" title="Go to Home">
                <i class="fas fa-home"></i>
              </a>
              <a href="https://medzk-server.onrender.com/record/environment" class="home-icon" title="Play Game" aria-label="Play Game">
                <i class="fas fa-gamepad"></i>
              </a>
              
            </div>
          
        </div>
      </div>
      

      

    <div id="info-window" class="draggable"></div>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    
   

  <div class="fab-container">
      <button class="fab-button" id="dashboardButton">
          <span class="fab-icon">📊</span>
      </button>
  </div>

  <div id="custom-alert" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeCustomAlert()">&times;</span>
        <p id="alert-message"></p>
        <button id="alert-ok-btn" onclick="confirmAlert()">OK</button>
        <div class="duration-indicator" id="durationIndicator">
            Confetti Duration: <span id="durationCount">0</span>s
        </div>
        <div class="button-container">
            <button class="control-btn celebrate-btn" id="celebrateBtn" onclick="createConfetti()">Celebrate! 🎉</button>
            <button class="control-btn stop-btn" id="stopBtn" onclick="stopConfetti()">Stop 🛑</button>
        </div>
    </div>
</div>
  
  <div class="dashboard-panel" id="dashboardPanel">
      <button class="panel-close-btn">×</button>
      <div class="dashboard">
          <!-- Your existing dashboard content -->
          <div class="card">
              <h2>Air Quality Index</h2>
              <svg class="gauge" viewBox="0 0 200 200">
                  <circle class="gauge-bg" cx="100" cy="100" r="90"/>
                  <circle class="gauge-progress" cx="100" cy="100" r="90"/>
                  <text class="gauge-value" x="100" y="120" text-anchor="middle">0</text>
              </svg>
          </div>
          <div class="card">
              <h2>Temperature & Humidity</h2>
              <canvas id="tempHumidityChart"></canvas>
          </div>
          <div class="card">
              <h2>Pollutants</h2>
              <ul class="pollutant-list" id="pollutantList"></ul>
          </div>
          <div class="card">
              <h2>Health Recommendations</h2>
              <div id="recommendations" style="padding: 20px;"></div>
          </div>
          <div id="leaderboard" class="leaderboard card">
            <h2>Leaderboard</h2>
            <ul id="leaderboard-list">
                <!-- Player scores will be dynamically inserted here -->
            </ul>
        </div>
      </div>
  </div>



  <!-- Template variables for API keys -->
  <script>
    window.GOOGLE_MAPS_API_KEY = '{{GOOGLE_MAPS_API_KEY}}';
    window.OPENWEATHER_API_KEY = '{{OPENWEATHER_API_KEY}}';
  </script>
  


    <!-- Required External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>

    <!-- Google Maps Libraries -->
    <script async defer>
        (g => { var h, a, k, p = "The Google Maps JavaScript API", c = "google", l = "importLibrary", q = "__ib__", m = document, b = window; b = b[c] || (b[c] = {}); var d = b.maps || (b.maps = {}), r = new Set, e = new URLSearchParams, u = () => h || (h = new Promise(async (f, n) => { await (a = m.createElement("script")); e.set("libraries", [...r] + ""); for (k in g) e.set(k.replace(/[A-Z]/g, t => "_" + t[0].toLowerCase()), g[k]); e.set("callback", c + ".maps." + q); a.src = `https://maps.${c}apis.com/maps/api/js?` + e; d[q] = f; a.onerror = () => h = n(Error(p + " could not load.")); a.nonce = m.querySelector("script[nonce]")?.nonce || ""; m.head.append(a) })); d[l] ? console.warn(p + " only loads once. Ignoring:", g) : d[l] = (f, ...n) => r.add(f) && u().then(() => d[l](f, ...n)) })({
            key: window.GOOGLE_MAPS_API_KEY,
            v: "alpha",
        });
    </script>
    <script>
      let map3DElement = null;
      let placesService = null;
      let advancedFeatures = null;
      let directionsRenderer = null; 


      class InteractiveMarker {
    constructor(map3DElement, place) {
        this.map3DElement = map3DElement;
        this.place = place;
        this.marker = null;
        this.directionsRenderer = null; 
        
    }

    async create() {
        // Import Marker3DInteractiveElement
        const { Marker3DInteractiveElement } = await google.maps.importLibrary("maps3d");
              
        // Create an instance of Marker3DInteractiveElement
        this.marker = new Marker3DInteractiveElement({
            position: {
                lat: this.place.location.lat(),
                lng: this.place.location.lng(),
                altitude: 0, // Assuming altitude is optional
            },
            label: this.place.name,
            sizePreserved: true, // Preserve marker size regardless of zoom
        });

        // Add click event listener to the marker
         this.marker.addEventListener('gmp-click', async () => {
        // Call zoomAndFlyToLocation when marker is clicked
            await zoomAndFlyToLocation(this.map3DElement, {
               lat: this.place.location.lat(),
               lng: this.place.location.lng(),
            });

            // Ask for confirmation to display route (new)
            const showRoute = confirm(`Show route to ${this.place.displayName}?`); // Use place name
            
            if (showRoute) {
              navigator.geolocation.getCurrentPosition(
                async (position) => {
                    const originLatLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);

                    // Reverse geocode current location to get Place ID (important!)
                    const geocoder = new google.maps.Geocoder();
                    geocoder.geocode({ location: originLatLng }, async (results, status) => {
                        if (status === 'OK' && results[0]) {
                            const originPlaceId = results[0].place_id;
                            displayRoute(originPlaceId, this.place.id, this); // Use Place IDs here
                        } else {
                            console.error('Geocoding failed:', status);
                            // Handle error, maybe use LatLng as fallback?
                            displayRoute(originLatLng, this.place.id, this); // Fallback to LatLng

                        }
                    });
                },
                (error) => { // ... (error handling, potentially also reverse geocode fallback location)
                }
              );
            }

        // Show info window
        this.showInfoWindow();
    });
        
        // Append the marker to the map's 3D element
        this.map3DElement.append(this.marker);
    }
    

    async showInfoWindow() {
        const infoWindow = document.getElementById("info-window");
        
        // Simulated fetch for additional data
        const data = await this.fetchData();
        
        // Populate and display the info window
        infoWindow.innerHTML = `
           <div class="info-card">
        <button class="close-btn" id="close-btn"   onclick="const infoWindow = document.getElementById('info-window'); infoWindow.style.display='none'; infoWindow.innerHTML='';">×</button>
        
        <h2 class="place-title truncate">
            🏢 ${this.place.displayName}
        </h2>
        
        <img src="${this.place.photos && this.place.photos.length > 0 ? 
           this.place.photos[0].getURI({ maxHeight: 150 }) : 
           'https://raw.githubusercontent.com/surfiniaburger/medzk-server/cd1afb17e0058ecf887f340ea8c1839f8925c716/mern/client/src/assets/groot.jpg'}"
            alt="${this.place.displayName}"
            class="place-image"
            onerror="this.src='https://raw.githubusercontent.com/surfiniaburger/medzk-server/cd1afb17e0058ecf887f340ea8c1839f8925c716/mern/client/src/assets/groot.jpg'">
        
        <div class="info-section truncate">
            📍 ${this.place.formattedAddress || "Address not available"}
        </div>
        
        <div class="info-section">
            <span class="rating">⭐ ${this.place.reviews[0]?.rating || 'N/A'}</span>
            👤 ${this.place.reviews[0]?.authorAttribution?.displayName || "Anonymous"}
        </div>
        
        <div class="info-section" style="max-height: 60px; overflow-y: auto;">
            💭 ${this.place.reviews[0]?.text || 'No reviews yet'}
        </div>
        <button onclick="completeTask('${this.place.id}')">Complete Task</button> 
          </div>

        `;
        infoWindow.style.display = "block";
    }
    
    async fetchData() {
        // Simulated data fetching with a delay
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve(`Simulated info for ${this.place.displayName}`);
            }, 1000);
        });
    }
}

// Global variable to track player scores
let playerScores = {};

// Function to complete a task and update scores
function completeTask(placeId) {
    const playerName = prompt("Enter your name:"); // Prompt for player name (or use a predefined name)
    if (!playerName) {
        showFailAlert("Player name is required!");
        return; // Exit if no name is provided
    }
    const pointsEarned = 10; // Points for completing a task

    // Update player's score
    if (!playerScores[playerName]) {
        playerScores[playerName] = 0; // Initialize score if player doesn't exist
    }
    playerScores[playerName] += pointsEarned;

      // Close and clear the info window
      const infoWindow = document.getElementById('info-window');
      infoWindow.style.display = 'none';
      infoWindow.innerHTML = '';

    // Update leaderboard
    updateLeaderboard(playerName, playerScores[playerName]);

    showCustomAlert(`Task completed! You earned ${pointsEarned} points.`);
     // Optionally update the dashboard display here
     upDashboard(); // Ensure this function updates the displayed score
}


const leaderboard = [];
const maxLeaderboardSize = 10; // Limit the number of displayed players




function upDashboard() {
    const scoreDisplay = document.getElementById('score-display');
    
    if (!scoreDisplay) {
        console.error("Score display element not found!");
        return;
    }
    
    // Calculate total score from all players (or adjust as needed)
    const totalScore = Object.values(playerScores).reduce((acc, score) => acc + score, 0);
    
    scoreDisplay.textContent = `Score: ${totalScore}`;
}

function updateLeaderboard(playerName, score) {
    // Check if player already exists in the leaderboard
    const existingPlayerIndex = leaderboard.findIndex(player => player.name === playerName);
    
    if (existingPlayerIndex > -1) {
        // Update the score if player exists
        leaderboard[existingPlayerIndex].score = score;
    } else {
        // Add new player to the leaderboard
        leaderboard.push({ name: playerName, score });
    }
    
    // Sort the leaderboard by score in descending order
    leaderboard.sort((a, b) => b.score - a.score);
    
    // Limit to max size
    if (leaderboard.length > maxLeaderboardSize) {
        leaderboard.pop(); // Remove the lowest score if exceeding max size
    }
    
    renderLeaderboard();
}

function renderLeaderboard() {
    const leaderboardList = document.getElementById('leaderboard-list');
    
    // Clear current list
    leaderboardList.innerHTML = '';
    
    // Populate the list with current leaderboard data
    leaderboard.forEach(player => {
        const listItem = document.createElement('li');
        listItem.textContent = `${player.name}: ${player.score}`;
        leaderboardList.appendChild(listItem);
    });
}


function showCustomAlert(message) {
    const alertModal = document.getElementById("custom-alert");
    const alertMessage = document.getElementById("alert-message");

    alertMessage.textContent = message; // Set the custom message

    alertModal.style.display = "block"; // Show modal

    // Animate modal appearance
    gsap.fromTo(alertModal, { scale: 0 }, { scale: 1, duration: 0.5, ease: "power2.out" });

   
        // Success: Play original sound and show confetti
        const successAudio = new Audio('https://github.com/surfiniaburger/medzk-server/raw/refs/heads/main/mern/server/routes/views/baby-laugh.mp3');
        Promise.all([
            successAudio.play(),
            createConfetti() // Show confetti only for success
        ]);
}

function showFailAlert(message) {
    const alertModal = document.getElementById("custom-alert");
    const alertMessage = document.getElementById("alert-message");
    
    alertMessage.textContent = message; // Set message
    alertModal.style.display = "block"; // Show modal
    
    // Animate modal appearance
    gsap.fromTo(alertModal, { scale: 0 }, { scale: 1, duration: 0.5, ease: "power2.out" });

    // Play sound effect for opening
    const audio = new Audio('https://github.com/surfiniaburger/medzk-server/raw/refs/heads/main/mern/server/routes/views/baby-cry.mp3'); // Add your sound file path
   
     Promise.all([
     audio.play(),
    ]);
}

function closeCustomAlert() {
    const alertModal = document.getElementById("custom-alert");
    
    // Animate modal closing effect
    gsap.to(alertModal, { scale: 0, duration: 0.5, ease: "power2.in", onComplete: () => {
        alertModal.style.display = 'none'; // Hide after animation
        alertModal.innerHTML = ''; // Clear content if necessary
        // // Play sound effect for closing
        // const audio = new Audio('./Teni.mp3'); // Add your sound file path
        // audio.play();
       
    }});
}

function confirmAlert() {
   closeCustomAlert(); // Close the alert when confirmed
}

 // Confetti Implementation
 const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const celebrateBtn = document.getElementById('celebrateBtn');
        const stopBtn = document.getElementById('stopBtn');
        const durationIndicator = document.getElementById('durationIndicator');
        const durationCount = document.getElementById('durationCount');
        
        let isConfettiActive = false;
        let confettiDuration = 0;
        let durationInterval = null;
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        class Confetti {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = -10;
                this.size = Math.random() * 5 + 5;
                this.speed = Math.random() * 3 + 2;
                this.angle = Math.random() * 360;
                this.spin = Math.random() * 8 - 4;
                this.color = `hsl(${Math.random() * 360}, 70%, 50%)`;
            }
            
            update() {
                this.y += this.speed;
                this.angle += this.spin;
                
                if (this.y > canvas.height + 10) {
                    this.reset();
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle * Math.PI / 180);
                
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                
                ctx.restore();
            }
        }
        
        const confettiParticles = [];
        let animationId = null;
        
        function createConfetti() {
            if (isConfettiActive) return;
            
            isConfettiActive = true;
            confettiDuration = 0;
            
            // Clear existing particles and animation
            confettiParticles.length = 0;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Create new particles
            for (let i = 0; i < 100; i++) {
                confettiParticles.push(new Confetti());
            }
            
            // Update UI
            celebrateBtn.classList.add('confetti-active');
            stopBtn.style.display = 'block';
            durationIndicator.style.display = 'block';
            
            // Start duration counter
            durationInterval = setInterval(() => {
                confettiDuration++;
                durationCount.textContent = confettiDuration;
                
                // Auto-stop after 30 seconds
                if (confettiDuration >= 30) {
                    stopConfetti();
                }
            }, 1000);
            
            // Start animation
            animate();
            
            // Play celebration sound
            //const audio = new Audio('https://github.com/surfiniaburger/medzk-server/raw/refs/heads/main/mern/server/routes/views/toy-short.mp3');
            //audio.play().catch(e => console.log('Audio play failed:', e));
        }
        
        function stopConfetti() {
            isConfettiActive = false;
            
            // Stop animation
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Reset particles
            confettiParticles.length = 0;
            
            // Update UI
            celebrateBtn.classList.remove('confetti-active');
            stopBtn.style.display = 'none';
            clearInterval(durationInterval);
            
            // Hide duration indicator after a delay
            setTimeout(() => {
                durationIndicator.style.display = 'none';
            }, 2000);
        }
        
        function animate() {
            if (!isConfettiActive) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            confettiParticles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            animationId = requestAnimationFrame(animate);
        }




document.addEventListener('DOMContentLoaded', function () {
  const searchIcon = document.getElementById('searchIcon');
  const popup = document.getElementById('popup');
  const popupCloseBtn = document.getElementById('popupCloseBtn');

  // Show popup and stop shaking animation
  searchIcon.addEventListener('click', function () {
    popup.style.display = 'flex';
    searchIcon.style.animation = 'none';
  });

  // Close popup
  popupCloseBtn.addEventListener('click', function () {
    popup.style.display = 'none';
    searchIcon.style.animation = 'shake 1s infinite alternate'; // Restart shake animation
  });

  // Close popup when clicking outside content
  popup.addEventListener('click', function (event) {
    if (event.target === popup) {
      popup.style.display = 'none';
      searchIcon.style.animation = 'shake 1s infinite alternate';
    }
  });

  // Close popup when pressing Escape
  document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape' && popup.style.display === 'flex') {
      popup.style.display = 'none';
      searchIcon.style.animation = 'shake 1s infinite alternate';
    }
  });
});


async function zoomAndFlyToLocation(map3DElement, location) {
    if (!map3DElement) return;

    const initialHeading = map3DElement.heading || 0;

    // Fly to the location
    let currentHeading = initialHeading;
    const steps = 100; // Number of frames for the animation
    const rangeReduction = (map3DElement.range - 300) / steps; // Gradual zoom
    const headingIncrement = 360 / steps; // Rotate the camera 360 degrees
    const intervalDuration = 50; // Duration per frame in milliseconds

    for (let i = 0; i < steps; i++) {
        // Update the map's camera properties gradually
        map3DElement.center = {
            lat: location.lat,
            lng: location.lng,
            altitude: 30, // Zoom close to the pin
        };
        map3DElement.range -= rangeReduction;
        map3DElement.heading = (currentHeading + headingIncrement) % 360; // Rotate around
        map3DElement.tilt = 65;

        currentHeading += headingIncrement;
        await new Promise((resolve) => setTimeout(resolve, intervalDuration));
    }

    console.log("Camera zoomed and flew to the marker position.");
}

// Create overlay element
const overlay = document.createElement('div');
overlay.className = 'overlay';
document.body.appendChild(overlay);

// Get elements
const dashboardButton = document.getElementById('dashboardButton');
const dashboardPanel = document.getElementById('dashboardPanel');
const closeBtn = document.querySelector('.panel-close-btn');

// Toggle dashboard
function toggleDashboard() {
    const isVisible = dashboardPanel.style.display === 'block';
    
    if (isVisible) {
        dashboardPanel.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        dashboardPanel.style.display = 'block';
        overlay.style.display = 'block';
    }
}

// Event listeners
dashboardButton.addEventListener('click', toggleDashboard);
closeBtn.addEventListener('click', toggleDashboard);
overlay.addEventListener('click', toggleDashboard);

// Optional: Close dashboard when pressing Escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && dashboardPanel.style.display === 'block') {
        toggleDashboard();
    }
});

    
      async function init() {
        const { Map3DElement } = await google.maps.importLibrary("maps3d");
        map3DElement = new Map3DElement({
          center: { lat: 0, lng: 0, altitude: 16000000 },
         // Adjust as needed
        });

        //await initializeMapAndElements();
        document.body.append(map3DElement);
        initAutocomplete();
        initPlacesService();

      }
    
      async function initAutocomplete() {
        const { Autocomplete } = await google.maps.importLibrary("places");
        const autocomplete = new Autocomplete(
          document.getElementById("pac-input"),
          {
            fields: ["geometry", "name", "place_id"],
          }
        );
    
        autocomplete.addListener("place_changed", () => {
          const place = autocomplete.getPlace();
          if (!place.geometry || !place.geometry.viewport) {
            window.alert("No viewport for input: " + place.name);
            return;
          }
          zoomToViewport(place.geometry);
        });
      }
    
      async function zoomToViewport(geometry) {
        const { AltitudeMode, Polyline3DElement } = await google.maps.importLibrary("maps3d");
        let viewport = geometry.viewport;
        let locationPoints = [
          { lat: viewport.getNorthEast().lat(), lng: viewport.getNorthEast().lng() },
          { lat: viewport.getSouthWest().lat(), lng: viewport.getNorthEast().lng() },
          { lat: viewport.getSouthWest().lat(), lng: viewport.getSouthWest().lng() },
          { lat: viewport.getNorthEast().lat(), lng: viewport.getSouthWest().lng() },
          { lat: viewport.getNorthEast().lat(), lng: viewport.getNorthEast().lng() }
        ];
    
        let locationPolyline = new Polyline3DElement({
          altitudeMode: AltitudeMode.CLAMP_TO_GROUND,
          strokeColor: "blue",
          strokeWidth: 10,
          coordinates: locationPoints,
        });
        map3DElement.append(locationPolyline);
    
        let elevation = await getElevationForPoint(geometry.location);
        if (map3DElement) {
          map3DElement.center = { lat: geometry.location.lat(), lng: geometry.location.lng(), altitude: elevation + 50 };
          map3DElement.heading = 0;
          map3DElement.range = 1000;
          map3DElement.tilt = 65;
        }
    
        initNearbySearch(geometry.location);
        await fetchEnvironmentalData(geometry.location);
      }
    
      async function initPlacesService() {
        const { PlacesService } = await google.maps.importLibrary("places");
        placesService = new PlacesService(map3DElement);
      }
      async function initNearbySearch(location) {
    if (!placesService) {
        console.error("PlacesService not initialized.");
        return;
    }

    const { Place, SearchNearbyRankPreference } = await google.maps.importLibrary("places");
    let center;
        if (location instanceof google.maps.LatLng) {
            center = location;
        } else {
            center = new google.maps.LatLng(location.lat, location.lng); // Create LatLng if needed
        }
    const request = {
        fields: ["id", "displayName", "location","formattedAddress", "photos", "reviews",  "editorialSummary", "businessStatus"],
        locationRestriction: {
            center: center,
            radius: 1000, // Search within 1km
        },
        includedPrimaryTypes: ["hospital"],
        rankPreference: SearchNearbyRankPreference.POPULARITY,
        language: "en-US",
        region: "us",
        maxResultCount: 10,
    };

    try {
        const { places } = await Place.searchNearby(request);

        if (places && places.length > 0) { // Ensure there are places available
            console.log("Nearby Search Results:", places);

            places.forEach((place, index) => {
                // Check if location data is present
                if (place.location) { // Correctly access the location property
                    const lat = place.location.lat(); // Access latitude using lat() method
                    const lng = place.location.lng(); // Access longitude using lng() method
                    
                    console.log(`Location of Place ${index + 1}:`, {
                        lat: lat,
                        lng: lng
                    });

                    if (!place.id) {
                    console.warn("Place ID is missing for:", place); // Handle missing Place ID

                }

                    // Create an interactive marker for each place
                    const marker = new InteractiveMarker(map3DElement, place);
                    marker.create();
                } else {
                    console.error(`Place ${index + 1} location data is missing.`);
                }
            });
        } else {
            console.log("No results found.");
        }
    } catch (error) {
        console.error("Nearby search failed:", error);
    }
}

      function addMarker(place) {
        const { Marker3DElement } = google.maps.maps3d;
        const marker = new Marker3DElement({
          position: {
            lat: place.geometry.location.lat(),
            lng: place.geometry.location.lng(),
            altitude: 0, // Adjust if necessary
          },
          label: place.name,
          sizePreserved: true,
        });
        map3DElement.append(marker);
      }
    
      async function getElevationForPoint(location) {
        const { ElevationService } = await google.maps.importLibrary("elevation");
        const elevatorService = new google.maps.ElevationService();
        const elevationResponse = await elevatorService.getElevationForLocations({
          locations: [location],
        });
    
        if (!(elevationResponse.results && elevationResponse.results.length)) {
          window.alert("Insufficient elevation data.");
          return 0;
        }
        return elevationResponse.results[0].elevation || 10;
      }

    
// Traffic condition color mapping
const TRAFFIC_COLORS = {
    NORMAL: '#4CAF50',     // Green
    SLOW: '#FFA726',       // Orange
    TRAFFIC_JAM: '#E53935' // Red
};

const DEFAULT_POLYLINE_OPTIONS = {
    geodesic: true,
    strokeOpacity: 1.0,
    strokeWeight: 3,
    zIndex: 1
};

/**
 * Displays a route on the map with traffic-aware styling
 * @param {google.maps.LatLng} origin - Starting point
 * @param {google.maps.LatLng} destination - Ending point
 * @param {Object} markerInstance - Instance containing map references
 * @returns {Promise<void>}
 */
async function displayRoute(originPlaceId, destinationPlaceId, markerInstance) {
    try {
        // Clear existing route if any
        clearExistingRoute(markerInstance);

        // Fetch and validate route data
        const routeData = await fetchRoutes(originPlaceId, destinationPlaceId);
        console.log(routeData)
        if (!isValidRouteData(routeData)) {
            if (!routeData) return false; // Check for null/undefined
            if (!routeData.success) return false; // Check server response status
            if (!(routeData.routes && routeData.routes.length > 0)) return false; // Check for presence of routes
            if (!(routeData.routes[0].legs && routeData.routes[0].legs.length > 0)) {
            console.error('Route is missing legs array:', routeData); // Log error for debugging
               return false; // No legs data means invalid, but warn about it
          }
          return true;
        }

        const route = routeData.routes[0];
        // Clear any existing route (Important!)
        if (markerInstance.polyline) {  // Update to polyline!
            markerInstance.polyline.setMap(null);
        }
        console.log(route + " route")
        const polylines = await createTrafficAwarePolylines(route, markerInstance.map3DElement);
        
        // Store polylines for later cleanup
        markerInstance.polyline = polylines;

        // Optionally fit bounds to show entire route
        fitMapToRoute(route, markerInstance.map3DElement);

        // Display route information if needed
        displayRouteInfo(route);

    } catch (error) {
        console.error('Error displaying route:', error);
        handleRouteError(error);
    }
}

/**
 * Clears existing route from the map
 * @param {Object} markerInstance 
 */
function clearExistingRoute(markerInstance) {
    if (markerInstance.directionsRenderer) {
        if (Array.isArray(markerInstance.directionsRenderer)) {
            markerInstance.directionsRenderer.forEach(polyline => polyline.setMap(null));
        } else {
            markerInstance.directionsRenderer.setMap(null);
        }
    }
}

/**
 * Creates traffic-aware polylines for the route
 * @param {Object} route - Route data from API
 * @param {google.maps.Map} map - Map instance
 * @returns {Array<google.maps.Polyline>}
 */
async function createTrafficAwarePolylines(route, map) {
    const { Polyline3DElement, AltitudeMode, LatLngAltitude } = await google.maps.importLibrary("maps3d");
    
    
    
    // Decode polyline into LatLngAltitude array
    const path = google.maps.geometry.encoding.decodePath(route.polyline.encodedPolyline).map(
        (latLng) => new LatLngAltitude({ lat: latLng.lat(), lng: latLng.lng() }) // Convert to LatLngAltitude
    );
    // Return a single polyline for the entire route
    const polyline = new Polyline3DElement({ 
        path,
        strokeColor: '#0000ff', // Example color, use what makes sense
        strokeWidth: 8,
        altitudeMode: AltitudeMode.CLAMP_TO_GROUND,
        map // Add polyline to map directly
    });
    return polyline; // Return the Polyline3DElement

    // Create separate polylines for each traffic segment
    return route.travelAdvisory.speedReadingIntervals.map(interval => {
        const segmentPath = path.slice(
            interval.startPolylinePointIndex || 0,
            interval.endPolylinePointIndex
        );

        return new Polyline3DElement({
            ...DEFAULT_POLYLINE_OPTIONS,
            path: segmentPath,
            strokeColor: TRAFFIC_COLORS[interval.speed] || TRAFFIC_COLORS.NORMAL,
            map: map
        });
        map.append(polyline);
    });
}

/**
 * Fetches route data from the API
 * @param {google.maps.LatLng} origin 
 * @param {google.maps.LatLng} destination 
 * @returns {Promise<Object>}
 */
 
async function fetchRoutes(originPlaceId, destinationPlaceId) {
    console.log(originPlaceId + " origin")
    console.log(destinationPlaceId + " destination")
    try {
        const response = await fetch(
            `https://medzk-server.onrender.com/record/route/${originPlaceId}/${destinationPlaceId}` 
        );

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Routes API request failed: ${response.status} - ${errorText}`);
        }

        return await response.json();
    } catch (error) {
        console.error("Error fetching route:", error);
        throw new Error('Failed to fetch route data. Please try again.');
    }
}

/**
 * Validates route data structure
 * @param {Object} routeData 
 * @returns {boolean}
 */
function isValidRouteData(routeData) {
    return routeData && 
           routeData.routes && 
           routeData.routes.length > 0 && 
           routeData.routes[0].polyline?.encodedPolyline;
}

/**
 * Fits the map bounds to show the entire route
 * @param {Object} route 
 * @param {google.maps.Map} map 
 */
function fitMapToRoute(route, map) {
    const bounds = new google.maps.LatLngBounds();
    const decodedPath = google.maps.geometry.encoding.decodePath(route.polyline.encodedPolyline);
    decodedPath.forEach(point => bounds.extend(point));
    map.fitBounds(bounds, { padding: 50 });
}

/**
 * Displays route information to the user
 * @param {Object} route 
 */
function displayRouteInfo(route) {
    const distance = (route.distance?.miles || route.distanceMeters / 1609.34).toFixed(1);
    const duration = Math.round((route.duration?.minutes || parseInt(route.duration.replace('s', '')) / 60));
    
    // You can customize how to display this information (e.g., in an InfoWindow, sidebar, etc.)
    console.log(`Distance: ${distance} miles`);
    console.log(`Estimated time: ${duration} minutes`);
}

/**
 * Handles and displays route errors
 * @param {Error} error 
 */
function handleRouteError(error) {
    // You can customize error handling based on your needs
    alert(`Could not calculate route: ${error.message}`);
}







      async function fetchEnvironmentalData(location) {
    const googleAirQualityUrl = `https://airquality.googleapis.com/v1/currentConditions:lookup?key=${window.GOOGLE_MAPS_API_KEY}`;
    const openWeatherAirQualityUrl = `https://api.openweathermap.org/data/2.5/air_pollution?lat=${location.lat()}&lon=${location.lng()}&appid=${window.OPENWEATHER_API_KEY}`;
    const weatherUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${location.lat()}&lon=${location.lng()}&appid=${window.OPENWEATHER_API_KEY}`;

    const googlePayload = {
        universalAqi: true,
        location: {
            latitude: location.lat(),
            longitude: location.lng(),
        },
        extraComputations: [
            "HEALTH_RECOMMENDATIONS",
            "DOMINANT_POLLUTANT_CONCENTRATION",
            "POLLUTANT_CONCENTRATION",
            "LOCAL_AQI",
            "POLLUTANT_ADDITIONAL_INFO",
        ],
        languageCode: "en",
    };

    try {
        // Try Google Air Quality API first
        const googleAirQualityResponse = await fetch(googleAirQualityUrl, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify(googlePayload),
        });

        if (!googleAirQualityResponse.ok) {
            throw new Error("Google Air Quality API request failed");
        }

        const googleAirQualityData = await googleAirQualityResponse.json();
        displayEnvironmentalData({
            source: 'google',
            data: googleAirQualityData
        });

    } catch (googleError) {
        console.warn("Falling back to OpenWeather API due to error:", googleError);

        try {
            // Fallback to OpenWeather API
            const [airQualityResponse, weatherResponse] = await Promise.all([
                fetch(openWeatherAirQualityUrl),
                fetch(weatherUrl),
            ]);

            const airQualityData = await airQualityResponse.json();
            const weatherData = await weatherResponse.json();

            displayEnvironmentalData({
                source: 'openweather',
                data: {
                    airQuality: airQualityData,
                    weather: weatherData
                }
            });
        } catch (fallbackError) {
            console.error("Failed to fetch environmental data:", fallbackError);
            displayError("Unable to fetch environmental data. Please try again later.");
        }
    }
}


function displayEnvironmentalData({ source, data }) {
    // Format data for visualization based on the source
    let formattedData = {
        aqi: 0,
        temperature: [],
        humidity: [],
        pollutants: [],
        recommendations: ''
    };

    if (source === 'google') {
      console.log("I used google")
        // Format Google API data
        formattedData = {
            aqi: data.indexes[0].aqi,
            temperature: [20, 21, 22, 23, 24, 25, 24, 23], // Default temperature data as Google API doesn't provide this
            humidity: [50, 52, 54, 53, 52, 51, 50, 49], // Default humidity data
            pollutants: data.pollutants.map(pollutant => ({
                name: pollutant.displayName,
                value: pollutant.concentration.value,
                unit: pollutant.concentration.units,
                max: getPollutantMaxValue(pollutant.displayName),
                color: getPollutantColor(pollutant.displayName)
            })),
            recommendations: data.healthRecommendations.generalPopulation
        };
    } else if (source === 'openweather') {
        // Format OpenWeather API data
        const airQuality = data.airQuality.list[0];
        const weather = data.weather;
        
        // Generate time-series data for temperature and humidity
        const currentHour = new Date().getHours();
        const tempData = [];
        const humidityData = [];
        for (let i = 0; i < 8; i++) {
            tempData.push((weather.main.temp - 273.15).toFixed(1));
            humidityData.push(weather.main.humidity);
        }

        formattedData = {
            aqi: airQuality.main.aqi * 20, // Convert OpenWeather 1-5 scale to 0-100 scale
            temperature: tempData,
            humidity: humidityData,
            pollutants: [
                {
                    name: 'PM2.5',
                    value: airQuality.components.pm2_5,
                    unit: 'μg/m³',
                    max: 50,
                    color: '#FF6384'
                },
                {
                    name: 'PM10',
                    value: airQuality.components.pm10,
                    unit: 'μg/m³',
                    max: 100,
                    color: '#36A2EB'
                },
                {
                    name: 'NO2',
                    value: airQuality.components.no2,
                    unit: 'μg/m³',
                    max: 100,
                    color: '#FFCE56'
                },
                {
                    name: 'O3',
                    value: airQuality.components.o3,
                    unit: 'μg/m³',
                    max: 100,
                    color: '#4BC0C0'
                }
            ],
            recommendations: getAQIRecommendation(airQuality.main.aqi)
        };
    }

    // Update the dashboard with formatted data
    updateDashboard(formattedData);
}

// Helper function to get max values for pollutants
function getPollutantMaxValue(pollutantName) {
    const maxValues = {
        'PM2.5': 50,
        'PM10': 100,
        'NO2': 100,
        'O3': 100,
        'CO': 10000,
        'SO2': 350
    };
    return maxValues[pollutantName] || 100;
}

// Helper function to get colors for pollutants
function getPollutantColor(pollutantName) {
    const colors = {
        'PM2.5': '#FF6384',
        'PM10': '#36A2EB',
        'NO2': '#FFCE56',
        'O3': '#4BC0C0',
        'CO': '#9966FF',
        'SO2': '#FF9F40'
    };
    return colors[pollutantName] || '#999999';
}

// Helper function to get AQI recommendations
function getAQIRecommendation(aqiLevel) {
    const recommendations = {
        1: "Air quality is good. Perfect for outdoor activities!",
        2: "Air quality is fair. Most people can continue outdoor activities.",
        3: "Air quality is moderate. Sensitive individuals should limit prolonged outdoor exposure.",
        4: "Air quality is poor. Avoid prolonged outdoor activities.",
        5: "Air quality is very poor. Stay indoors if possible."
    };
    return recommendations[aqiLevel] || "No specific recommendations available.";
}

// Function to handle errors
function displayError(message) {
    const formattedData = {
        aqi: 0,
        temperature: Array(8).fill(0),
        humidity: Array(8).fill(0),
        pollutants: [],
        recommendations: `Error: ${message}`
    };
    updateDashboard(formattedData);
}

document.addEventListener("DOMContentLoaded", () => {
    const draggables = document.querySelectorAll(".draggable");

    draggables.forEach((element) => {
        element.addEventListener("mousedown", (e) => {
            let shiftX = e.clientX - element.getBoundingClientRect().left;
            let shiftY = e.clientY - element.getBoundingClientRect().top;

            const moveAt = (pageX, pageY) => {
                element.style.left = pageX - shiftX + "px";
                element.style.top = pageY - shiftY + "px";
            };

            const onMouseMove = (event) => {
                moveAt(event.pageX, event.pageY);
            };

            document.addEventListener("mousemove", onMouseMove);

            element.addEventListener("mouseup", () => {
                document.removeEventListener("mousemove", onMouseMove);
                element.onmouseup = null;
            });

            // Prevent default drag-and-drop behavior
            element.ondragstart = () => false;
        });
    });
});



class Marker3DInteractiveElement {
  constructor({ position, label, iconUrl, interactive = true }) {
    this.position = position;
    this.label = label;
    this.iconUrl = iconUrl;
    this.interactive = interactive;
    this.marker = null;
  }

  async create(map3DElement) {
    const { Marker3DElement } = await google.maps.importLibrary("maps3d");
    this.marker = new Marker3DElement({
      position: this.position,
      label: this.label,
      icon: this.iconUrl,
      sizePreserved: true,
    });
    map3DElement.append(this.marker);

    if (this.interactive) {
      this.marker.addEventListener("click", () => {
        new PlaceClick().handleClick(this.position);
      });
    }
  }
}

class PlaceClick {
  handleClick(position) {
    alert(`Clicked on marker at: ${position.lat}, ${position.lng}`);
    // Fetch and display more detailed information or navigate on the map
  }
}

class Model3DElement {
  constructor({ position, modelUrl }) {
    this.position = position;
    this.modelUrl = modelUrl;
    this.model = null;
  }

  async create(map3DElement) {
    const { Model3DElement } = await google.maps.importLibrary("maps3d");
    this.model = new Model3DElement({
      position: this.position,
      model: this.modelUrl,
      scale: 1,
    });
    map3DElement.append(this.model);
  }
}

async function initializeMapAndElements() {
  if (!map3DElement) {
    console.error("map3DElement is not initialized.");
    return;
  }

  const mapCenter = { lat: 40.748817, lng: -73.985428 }; // Example location

  try {
    // Add an interactive marker
    const interactiveMarker = new google.maps.maps3d.Marker3DInteractiveElement({
      position: mapCenter,
      label: "Empire State Building",
    });

    interactiveMarker.addEventListener("gmp-click", () => {
      alert("Clicked on: Empire State Building");
    });

    map3DElement.append(interactiveMarker);

    // Add a 3D model
    const model = new google.maps.maps3d.Model3DElement({
      position: mapCenter,
      src: "https://github.com/surfiniaburger/medzk-server/raw/refs/heads/main/mern/client/src/assets/groot-model.glb",
      scale: 1.0, // Adjust as needed
    });

    map3DElement.append(model);
  } catch (error) {
    console.error("Failed to initialize map and elements:", error);
  }
}   


function updateDashboard(data) {
            // Update AQI Gauge
            updateGauge(data.aqi);
            
            // Update Temperature & Humidity Chart
            updateTempHumidityChart(data.temperature, data.humidity);
            
            // Update Pollutants
            updatePollutants(data.pollutants);
            
            // Update Recommendations
            updateRecommendations(data.recommendations);
        }

        // Gauge animation
        function updateGauge(value) {
            const progress = document.querySelector('.gauge-progress');
            const valueText = document.querySelector('.gauge-value');
            const circumference = 2 * Math.PI * 90;
            const offset = circumference - (value / 500) * circumference;
            
            progress.style.strokeDasharray = circumference;
            progress.style.strokeDashoffset = offset;
            
            // Color based on AQI value
            let color;
            if (value <= 50) color = '#00C853';
            else if (value <= 100) color = '#FFD600';
            else if (value <= 150) color = '#FF6D00';
            else color = '#D50000';
            
            progress.style.stroke = color;
            
            gsap.to(valueText, {
                innerHTML: Math.round(value),
                duration: 1,
                snap: { innerHTML: 1 }
            });
        }

        let tempHumidityChart = null;

        // Temperature & Humidity Chart
        function updateTempHumidityChart(temp, humidity) {
            const ctx = document.getElementById('tempHumidityChart').getContext('2d');

            // Destroy existing chart if it exists
            if (tempHumidityChart) {
                 tempHumidityChart.destroy();
             }
            tempHumidityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['12am', '3am', '6am', '9am', '12pm', '3pm', '6pm', '9pm'],
                    datasets: [{
                        label: 'Temperature (°C)',
                        data: temp,
                        borderColor: '#FF6384',
                        tension: 0.4,
                        fill:false
                    }, {
                        label: 'Humidity (%)',
                        data: humidity,
                        borderColor: '#36A2EB',
                        tension: 0.4,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    animation: {
                        duration: 2000,
                        easing: 'easeInOutQuart'
                    },
                    scales: {
                y: {
                    beginAtZero: false,
                    ticks: {
                        callback: function(value) {
                            return value.toFixed(1);
                        }
                    }
                }
            },
            plugins: {
                legend: {
                    position: 'top'
                }
            }
                }
            });
        }

        // Optional: Clean up function to be called when needed
       function destroyCharts() {
       if (tempHumidityChart) {
          tempHumidityChart.destroy();
          tempHumidityChart = null;
        }
      }

        // Pollutants List
        function updatePollutants(pollutants) {
            const list = document.getElementById('pollutantList');
            list.innerHTML = '';
            
            pollutants.forEach(pollutant => {
                const item = document.createElement('li');
                item.className = 'pollutant-item';
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between;">
                        <span>${pollutant.name}</span>
                        <span>${pollutant.value} ${pollutant.unit}</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="background: ${pollutant.color};"></div>
                    </div>
                `;
                list.appendChild(item);
                
                // Animate progress bar
                setTimeout(() => {
                    item.querySelector('.progress-fill').style.width = `${(pollutant.value / pollutant.max) * 100}%`;
                }, 100);
            });
        }

        // Health Recommendations
        function updateRecommendations(recommendations) {
            const container = document.getElementById('recommendations');
            container.innerHTML = `
                <div style="opacity: 0; transform: translateY(20px);">
                    ${recommendations}
                </div>
            `;
            
            gsap.to(container.children[0], {
                opacity: 1,
                y: 0,
                duration: 0.8,
                ease: "power2.out"
            });
        }


        // Emergency Response System
        class EmergencyResponseSystem {
            constructor(map3DElement) {
                this.map3DElement = map3DElement;
                this.emergencyMarkers = new Map();
                this.responders = new Map();
            }

            async initializeEmergencySystem() {
                // Initialize WebSocket connection for real-time updates
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('emergencyBtn').addEventListener('click', () => {
                    this.simulateEmergency();
                });
            }

            async simulateEmergency() {
                const emergencyAlert = document.getElementById('emergencyAlert');
                emergencyAlert.textContent = "Emergency services notified! Help is on the way.";
                emergencyAlert.style.display = 'block';
                
                // Create emergency marker
                const position = this.map3DElement.center;
                await this.createEmergencyMarker(position, 'MEDICAL', 3);
                
                setTimeout(() => {
                    emergencyAlert.style.display = 'none';
                }, 5000);
            }

            async createEmergencyMarker(location, type, severity) {
                const { Marker3DElement } = await google.maps.importLibrary("maps3d");
                
                const marker = new Marker3DElement({
                    position: location,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: severity * 10,
                        fillColor: this.getEmergencyColor(type),
                        fillOpacity: 0.7,
                        strokeWeight: 2
                    },
                    animation: google.maps.Animation.BOUNCE
                });

                this.map3DElement.append(marker);
                return marker;
            }

            getEmergencyColor(type) {
                const colors = {
                    'FIRE': '#FF4444',
                    'MEDICAL': '#33B5E5',
                    'POLICE': '#AA66CC',
                    'NATURAL_DISASTER': '#FFBB33'
                };
                return colors[type] || '#666666';
            }
        }

        

       

        // Community Features
        class CommunityFeatures {
            constructor(map3DElement) {
                this.map3DElement = map3DElement;
                this.events = new Map();
            }

            async initializeSocialFeatures() {
                document.getElementById('communityBtn').addEventListener('click', () => {
                    this.toggleCommunityPanel();
                });

                document.getElementById('createEventBtn').addEventListener('click', () => {
                    this.createNewEvent();
                });

                await this.loadCommunityEvents();
            }

            toggleCommunityPanel() {
                const panel = document.getElementById('communityPanel');
                panel.classList.toggle('active');
            }

            async loadCommunityEvents() {
                // Simulate loading events
                const events = [
                    { id: 1, name: 'Community Cleanup', date: '2024-02-01', attendees: 15 },
                    { id: 2, name: 'Local Market', date: '2024-02-05', attendees: 30 },
                ];

                const eventsList = document.getElementById('eventsList');
                eventsList.innerHTML = events.map(event => `
                    <div class="event-card">
                        <h4>${event.name}</h4>
                        <p>📅 ${event.date}</p>
                        <p>👥 ${event.attendees} attending</p>
                    </div>
                `).join('');
            }

            createNewEvent() {
                // Implement event creation logic
                alert('Event creation coming soon!');
            }
        }


      init();
    </script>
</body>
</html>